<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="本文对田老师写的flowgrid插件做详细的讲解，为此特地写了一个小项目，暂且就叫vue-dragrid，预览效果点击这里，下面会针对一个个commit来进行讲解，所有commit请看这里。">
<meta name="keywords" content="javascript,es6,webpack,vue">
<meta property="og:type" content="article">
<meta property="og:title" content="学习dashboard中网格拖拽效果的实现">
<meta property="og:url" content="https://elephantme.github.io/2017/08/05/vue-dragrid/index.html">
<meta property="og:site_name" content="Dong&#39;s Blog">
<meta property="og:description" content="本文对田老师写的flowgrid插件做详细的讲解，为此特地写了一个小项目，暂且就叫vue-dragrid，预览效果点击这里，下面会针对一个个commit来进行讲解，所有commit请看这里。">
<meta property="og:updated_time" content="2017-08-06T10:38:33.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学习dashboard中网格拖拽效果的实现">
<meta name="twitter:description" content="本文对田老师写的flowgrid插件做详细的讲解，为此特地写了一个小项目，暂且就叫vue-dragrid，预览效果点击这里，下面会针对一个个commit来进行讲解，所有commit请看这里。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://elephantme.github.io/2017/08/05/vue-dragrid/"/>





  <title>学习dashboard中网格拖拽效果的实现 | Dong's Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1a71164e95b5296508c0d1492855a5a0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dong's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">路漫漫其修远兮，吾将上下而求索</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://elephantme.github.io/2017/08/05/vue-dragrid/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">学习dashboard中网格拖拽效果的实现</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-05T11:37:18+08:00">
                2017-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>本文对<a href="https://github.com/tm-roamer" target="_blank" rel="external">田老师</a>写的<a href="https://github.com/tm-roamer/flowgrid" target="_blank" rel="external">flowgrid</a>插件做详细的讲解，为此特地写了一个小项目，暂且就叫<a href="https://github.com/elephantme/vue-dragrid" target="_blank" rel="external">vue-dragrid</a>，预览效果<a href="https://elephantme.github.io/vue-dragrid/">点击这里</a>，下面会针对一个个commit来进行讲解，所有commit<a href="https://github.com/elephantme/vue-dragrid/commits/master" target="_blank" rel="external">请看这里</a>。</p>
</blockquote>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>先clone项目到本地。</li>
<li><code>git reset --hard commit</code>命令可以使当前head指向某个commit。 </li>
</ol>
<h2 id="完成html的基本布局"><a href="#完成html的基本布局" class="headerlink" title="完成html的基本布局"></a>完成html的基本布局</h2><p>点击复制按钮来复制整个commit id。然后在项目根路径下运行<code>git reset</code>。用浏览器打开index.html来预览效果，该插件的html主要结果如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 节点容器 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dragrid"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 可拖拽的节点，使用translate控制位移 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dragrid-item"</span> <span class="attr">style</span>=<span class="string">"transform: translate(0px, 0px)"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 通过slot可以插入动态内容 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dragrid-item-content"</span>&gt;</span></div><div class="line">      </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 拖拽句柄 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dragrid-drag-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 缩放句柄 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dragrid-resize-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="使用vue完成nodes简单排版"><a href="#使用vue完成nodes简单排版" class="headerlink" title="使用vue完成nodes简单排版"></a>使用vue完成nodes简单排版</h2><p>先切换commit，安装需要的包，运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git reset --hard 83842ea107e7d819761f25bf06bfc545102b2944</div><div class="line">npm install</div><div class="line">&lt;!-- 启动，端口为7777，在package.json中可以修改 --&gt;</div><div class="line">npm start</div></pre></td></tr></table></figure>
<p>这一步一个是搭建环境，这个直接看webpack.config.js配置文件就可以了。</p>
<p>另一个就是节点的排版（layout），主要思路是把节点容器看成一个网格，每个节点就可以通过横坐标(x)和纵坐标(y)来控制节点的位置，左上角坐标为(0, 0)；通过宽(w)和高(h)来控制节点大小；每个节点还必须有一个唯一的id。这样节点node的数据结构就为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  id: "uuid",</div><div class="line">  x: 0,</div><div class="line">  y: 0,</div><div class="line">  w: 6,</div><div class="line">  h: 8</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中w和h的值为所占网格的格数，例如容器是24格，且宽度为960px，每格宽度就为40px，则上面节点渲染为240px * 320px, 且在容器左上角。</p>
<p>来看一下dragrid.vue与之对应的逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">computed: &#123;</div><div class="line">  cfg() &#123;</div><div class="line">    <span class="keyword">let</span> cfg = <span class="built_in">Object</span>.assign(&#123;&#125;, config);</div><div class="line">    cfg.cellW = <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.containerWidth / cfg.col);</div><div class="line">    cfg.cellH = cfg.cellW; <span class="comment">// 1:1</span></div><div class="line">    <span class="keyword">return</span> cfg;</div><div class="line">  &#125;</div><div class="line">&#125;,</div><div class="line"><span class="attr">methods</span>: &#123;</div><div class="line">  getStyle(node) &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">width</span>: node.w * <span class="keyword">this</span>.cfg.cellW + <span class="string">'px'</span>,</div><div class="line">      <span class="attr">height</span>: node.h * <span class="keyword">this</span>.cfg.cellH + <span class="string">'px'</span>,</div><div class="line">      <span class="attr">transform</span>: <span class="string">"translate("</span>+ node.x * <span class="keyword">this</span>.cfg.cellW +<span class="string">"px, "</span>+ node.y * <span class="keyword">this</span>.cfg.cellH +<span class="string">"px)"</span></div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中cellW、cellH为每个格子的宽和高，这样计算节点的宽和高及位移就很容易了。</p>
<h2 id="完成单个节点的拖拽"><a href="#完成单个节点的拖拽" class="headerlink" title="完成单个节点的拖拽"></a>完成单个节点的拖拽</h2><h3 id="拖拽事件"><a href="#拖拽事件" class="headerlink" title="拖拽事件"></a>拖拽事件</h3><ol>
<li>使用mousedown、mousemove、mouseup来实现拖拽。</li>
<li>这些事件绑定在document上，只需要绑定一次就可以。</li>
</ol>
<p>执行流程大致如下：</p>
<p>鼠标在拖拽句柄上按下，<code>onMouseDown</code>方法触发，在eventHandler中存储一些值之后，鼠标移动则触发<code>onMouseMove</code>方法，第一次进入时<code>eventHandler.drag</code>为false，其中isDrag方法会根据位移来判断是否是拖拽行为（横向或纵向移动5像素），如果是拖拽行为，则将drag属性设置为true，同时执行<code>dragdrop.dragStart</code>方法（一次拖拽行为只会执行一次），之后鼠标继续移动，则就开始执行<code>dragdrop.drag</code>方法了。最后鼠标松开后，会执行<code>onMouseUp</code>方法，将一些状态重置回初始状态，同时执行<code>dragdrop.dragEnd</code>方法。</p>
<h3 id="拖拽节点"><a href="#拖拽节点" class="headerlink" title="拖拽节点"></a>拖拽节点</h3><p>拖拽节点的逻辑都封装在dragdrop.js这个文件里，主要方法为<code>dragStart</code>、<code>drag</code>、<code>dragEnd</code>。</p>
<h4 id="dragStart"><a href="#dragStart" class="headerlink" title="dragStart"></a>dragStart</h4><p>在一次拖拽行为中，该方法只执行一次，因此适合做一些初始化工作，此时代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">dragStart(el, offsetX, offsetY) &#123;</div><div class="line">  <span class="comment">// 要拖拽的节点</span></div><div class="line">  <span class="keyword">const</span> dragNode = utils.searchUp(el, <span class="string">'dragrid-item'</span>);</div><div class="line">  <span class="comment">// 容器</span></div><div class="line">  <span class="keyword">const</span> dragContainer = utils.searchUp(el, <span class="string">'dragrid'</span>);</div><div class="line">  <span class="comment">// 拖拽实例</span></div><div class="line">  <span class="keyword">const</span> instance = cache.get(dragContainer.getAttribute(<span class="string">'name'</span>));</div><div class="line">  <span class="comment">// 拖拽节点</span></div><div class="line">  <span class="keyword">const</span> dragdrop = dragContainer.querySelector(<span class="string">'.dragrid-dragdrop'</span>);</div><div class="line">  <span class="comment">// 拖拽节点id</span></div><div class="line">  <span class="keyword">const</span> dragNodeId = dragNode.getAttribute(<span class="string">'dg-id'</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 设置拖拽节点</span></div><div class="line">  dragdrop.setAttribute(<span class="string">'style'</span>, dragNode.getAttribute(<span class="string">'style'</span>));</div><div class="line">  dragdrop.innerHTML = dragNode.innerHTML;</div><div class="line">  instance.current = dragNodeId;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> offset = utils.getOffset(el, dragNode, &#123;offsetX, offsetY&#125;);</div><div class="line">  <span class="comment">// 容器偏移</span></div><div class="line">  <span class="keyword">const</span> containerOffset = dragContainer.getBoundingClientRect();</div><div class="line"></div><div class="line">  <span class="comment">// 缓存数据</span></div><div class="line">  <span class="keyword">this</span>.offsetX = offset.offsetX;</div><div class="line">  <span class="keyword">this</span>.offsetY = offset.offsetY;</div><div class="line">  <span class="keyword">this</span>.dragrid = instance;</div><div class="line">  <span class="keyword">this</span>.dragElement = dragdrop;</div><div class="line">  <span class="keyword">this</span>.dragContainer = dragContainer;</div><div class="line">  <span class="keyword">this</span>.containerOffset = containerOffset;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>参数el为拖拽句柄元素，offsetX为鼠标距离拖拽句柄的横向偏移，offsetY为鼠标距离拖拽句柄的纵向偏移。</li>
<li>通过el可以向上递归查找到拖拽节点（dragNode），及拖拽容器（dragContainer）。</li>
<li>dragdrop元素是真正鼠标控制拖拽的节点，同时与之对应的布局节点会变为占位节点（placeholder），视觉上显示为阴影效果。</li>
<li>设置拖拽节点其实就将点击的dragNode的innerHTML设置到dragdrop中，同时将样式也应用过去。</li>
<li>拖拽实例，其实就是dragrid.vue实例，它在created钩子函数中将其实例缓存到cache中，在这里根据name就可以从cache中得到该实例，从而可以调用该实例中的方法了。</li>
<li><code>instance.current = dragNodeId;</code>设置之后，dragdrop节点及placeholder节点的样式就应用了。</li>
<li>缓存数据中的offsetX、offsetY是拖拽句柄相对于节点左上角的偏移。</li>
</ol>
<h4 id="drag"><a href="#drag" class="headerlink" title="drag"></a>drag</h4><p>发生拖拽行为之后，鼠标move都会执行该方法，通过不断更新拖拽节点的样式来是节点发生移动效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">drag(event) &#123;</div><div class="line">  <span class="keyword">const</span> pageX = event.pageX, pageY = event.pageY;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> x = pageX - <span class="keyword">this</span>.containerOffset.left - <span class="keyword">this</span>.offsetX,</div><div class="line">        y = pageY - <span class="keyword">this</span>.containerOffset.top - <span class="keyword">this</span>.offsetY;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.dragElement.style.cssText += <span class="string">';transform:translate('</span>+ x +<span class="string">'px, '</span>+ y +<span class="string">'px)'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要是计算节点相对于容器的偏移：鼠标距离页面距离-容器偏移-鼠标距离拽节点距离就为节点距离容器的距离。</p>
<h4 id="dragEnd"><a href="#dragEnd" class="headerlink" title="dragEnd"></a>dragEnd</h4><p>主要是重置状态。逻辑比较简单，就不再细说了。</p>
<p>到这里已经单个节点已经可以跟随鼠标进行移动了。</p>
<h2 id="使placeholder可以跟随拖拽节点运动"><a href="#使placeholder可以跟随拖拽节点运动" class="headerlink" title="使placeholder可以跟随拖拽节点运动"></a>使placeholder可以跟随拖拽节点运动</h2><p>本节是要讲占位节点(placeholder阴影部分)跟随拖拽节点一起移动。主要思路是：</p>
<ol>
<li>通过拖拽节点距离容器的偏移(drag方法中的x, y)，可以将其转化为对应网格的坐标。</li>
<li>转化后的坐标如果发生变化，则更新占位节点的坐标。</li>
</ol>
<p>drag方法中增加的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 坐标转换</span></div><div class="line"><span class="keyword">const</span> nodeX = <span class="built_in">Math</span>.round(x / opt.cellW);</div><div class="line"><span class="keyword">const</span> nodeY = <span class="built_in">Math</span>.round(y / opt.cellH);</div><div class="line"></div><div class="line"><span class="keyword">let</span> currentNode = <span class="keyword">this</span>.dragrid.currentNode;</div><div class="line"></div><div class="line"><span class="comment">// 发生移动</span></div><div class="line"><span class="keyword">if</span>(currentNode.x !== nodeX || currentNode.y !== nodeY) &#123;</div><div class="line">    currentNode.x = nodeX;</div><div class="line">    currentNode.y = nodeY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="nodes重排及上移"><a href="#nodes重排及上移" class="headerlink" title="nodes重排及上移"></a>nodes重排及上移</h2><p>本节核心点有两个：</p>
<ol>
<li>用一个二维数组来表示网格，这样节点的位置信息就可以在此二维数组中标记出来了。</li>
<li>nodes中只要某个节点发生变化，就要重新排版，要将每个节点尽可能地上移。</li>
</ol>
<h3 id="二维数组的构建"><a href="#二维数组的构建" class="headerlink" title="二维数组的构建"></a>二维数组的构建</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">getArea(nodes) &#123;</div><div class="line">  <span class="keyword">let</span> area = [];</div><div class="line">  nodes.forEach(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> row = n.y; row &lt; n.y + n.h; row++)&#123;</div><div class="line">      <span class="keyword">let</span> rowArr = area[row];</div><div class="line">      <span class="keyword">if</span>(rowArr === <span class="literal">undefined</span>)&#123;</div><div class="line">        area[row] = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> col = n.x; col &lt; n.x + n.w; col++)&#123;</div><div class="line">        area[row][col] = n.id;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> area;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按需可以动态扩展该二维数据，如果某行没有任何节点占位，则实际存储的是一个undefined值。否则存储的是节点的id值。</p>
<h3 id="布局方法"><a href="#布局方法" class="headerlink" title="布局方法"></a>布局方法</h3><p>dragird.vue中watch了nodes，发生变化后会调用layout方法，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 重新布局</div><div class="line"> * 只要有一个节点发生变化，就要重新进行排版布局</div><div class="line"> */</div><div class="line">layout() &#123;</div><div class="line">  <span class="keyword">this</span>.nodes.forEach(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> y = <span class="keyword">this</span>.moveup(n);</div><div class="line">    <span class="keyword">if</span>(y &lt; n.y)&#123;</div><div class="line">      n.y = y;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// 向上查找节点可以冒泡到的位置</span></div><div class="line">moveup(node) &#123;</div><div class="line">  <span class="keyword">let</span> area = <span class="keyword">this</span>.area;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> row = node.y - <span class="number">1</span>; row &gt; <span class="number">0</span>; row--)&#123;</div><div class="line">    <span class="comment">// 如果一整行都为空，则直接继续往上找</span></div><div class="line">    <span class="keyword">if</span>(area[row] === <span class="literal">undefined</span>) <span class="keyword">continue</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> col = node.x; col &lt; node.x + node.w; col++)&#123;</div><div class="line">      <span class="comment">// 改行如果有内容，则直接返回下一行</span></div><div class="line">      <span class="keyword">if</span>(area[row][col] !== <span class="literal">undefined</span>)&#123;</div><div class="line">        <span class="keyword">return</span> row + <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>布局方法layout中遍历所有节点，moveup方法返回该节点纵向可以上升到的位置坐标，如果比实际坐标小，则进行上移。moveup方法默认从上一行开始找，直到发现二维数组中存放了值（改行已经有元素了），则返回此时行数加1。</p>
<p>到这里，拖拽节点移动时，占位节点会尽可能地上移，如果只有一个节点，那么占位节点一直在最上面移动。</p>
<h2 id="相关节点的下移"><a href="#相关节点的下移" class="headerlink" title="相关节点的下移"></a>相关节点的下移</h2><p>拖拽节点移动时，与拖拽节点发生碰撞的节点及其下发的节点，都先下移一定距离，这样拖拽节点就可以移到相应位置，最后节点都会发生上一节所说的上移。</p>
<p>请看dragrid.vue中的overlap方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">overlap(node) &#123;</div><div class="line">  <span class="comment">// 下移节点</span></div><div class="line">  <span class="keyword">this</span>.nodes.forEach(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span>(node !== n &amp;&amp; n.y + n.h &gt; node.y) &#123;</div><div class="line">      n.y += node.h;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>n.y + n.h &gt; node.y</code> 表示可以与拖拽节点发生碰撞，以及在拖拽节点下方的节点。</p>
<p>在dragdrop.drag中会调用该方法。</p>
<p>注意目前该方法会有问题，没有考虑到如果碰撞节点比较高，则<code>n.y += node.h</code>并没有将该节点下沉到拖拽节点下方，从而拖拽节点会叠加上去。后面会介绍解决方法。</p>
<h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>上面的思路都理解之后，缩放其实也是一样的，主要还是要进行坐标转换，坐标发生变化后，就会调用overlap方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">resize(event) &#123;</div><div class="line">  <span class="keyword">const</span> opt = <span class="keyword">this</span>.dragrid.cfg;</div><div class="line"></div><div class="line">  <span class="comment">// 之前</span></div><div class="line">  <span class="keyword">const</span> x1 = <span class="keyword">this</span>.currentNode.x * opt.cellW + <span class="keyword">this</span>.offsetX,</div><div class="line">      y1 = <span class="keyword">this</span>.currentNode.y * opt.cellH + <span class="keyword">this</span>.offsetY;</div><div class="line">  <span class="comment">// 之后</span></div><div class="line">  <span class="keyword">const</span> x2 = event.pageX - <span class="keyword">this</span>.containerOffset.left,</div><div class="line">      y2 = event.pageY - <span class="keyword">this</span>.containerOffset.top;</div><div class="line">  <span class="comment">// 偏移</span></div><div class="line">  <span class="keyword">const</span> dx = x2 - x1, dy = y2 - y1;</div><div class="line">  <span class="comment">// 新的节点宽和高</span></div><div class="line">  <span class="keyword">const</span> w = <span class="keyword">this</span>.currentNode.w * opt.cellW + dx,</div><div class="line">      h = <span class="keyword">this</span>.currentNode.h * opt.cellH + dy;</div><div class="line"></div><div class="line">  <span class="comment">// 样式设置</span></div><div class="line">  <span class="keyword">this</span>.dragElement.style.cssText += <span class="string">';width:'</span> + w + <span class="string">'px;height:'</span> + h + <span class="string">'px;'</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 坐标转换</span></div><div class="line">  <span class="keyword">const</span> nodeW = <span class="built_in">Math</span>.round(w / opt.cellW);</div><div class="line">  <span class="keyword">const</span> nodeH = <span class="built_in">Math</span>.round(h / opt.cellH);</div><div class="line"></div><div class="line">  <span class="keyword">let</span> currentNode = <span class="keyword">this</span>.dragrid.currentNode;</div><div class="line"></div><div class="line">  <span class="comment">// 发生移动</span></div><div class="line">  <span class="keyword">if</span>(currentNode.w !== nodeW || currentNode.h !== nodeH) &#123;</div><div class="line">      currentNode.w = nodeW;</div><div class="line">      currentNode.h = nodeH;</div><div class="line">      <span class="keyword">this</span>.dragrid.overlap(currentNode);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据鼠标距拖拽容器的距离的偏移，来修改节点的大小（宽和高），其中x1为鼠标点击后距离容器的距离，x2为移动一段距离之后距离容器的距离，那么差值dx就为鼠标移动的距离，dy同理。</p>
<p>到这里，插件的核心逻辑基本上已经完成了。</p>
<h2 id="fix-解决碰撞位置靠上的大块，并没有下移的问题"><a href="#fix-解决碰撞位置靠上的大块，并没有下移的问题" class="headerlink" title="[fix]解决碰撞位置靠上的大块，并没有下移的问题"></a>[fix]解决碰撞位置靠上的大块，并没有下移的问题</h2><p>overlap修改为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">overlap(node) &#123;</div><div class="line">  <span class="keyword">let</span> offsetUpY = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 碰撞检测，查找一起碰撞节点里面，位置最靠上的那个</span></div><div class="line">  <span class="keyword">this</span>.nodes.forEach(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span>(node !== n &amp;&amp; <span class="keyword">this</span>.checkHit(node, n))&#123;</div><div class="line">      <span class="keyword">const</span> value = node.y - n.y;</div><div class="line">      offsetUpY = value &gt; offsetUpY ? value : offsetUpY;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="comment">// 下移节点</span></div><div class="line">  <span class="keyword">this</span>.nodes.forEach(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span>(node !== n &amp;&amp; n.y + n.h &gt; node.y) &#123;</div><div class="line">      n.y += (node.h + offsetUpY);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>offsetUpY 最终存放的是与拖拽节点发生碰撞的所有节点中，位置最靠上的节点与拖拽节点之间的距离。然后再下移过程中会加上该offsetUpY值，确保所有节点下移到拖拽节点下方。</p>
<p>这个插件的核心逻辑就说到这里了，读者可以自己解决如下一些问题：</p>
<ol>
<li>缩放限制，达到最小宽度就不能再继续缩放了。</li>
<li>拖拽控制滚动条。</li>
<li>拖拽边界的限制。</li>
<li>向下拖拽，达到碰撞节点1/2高度就发生换位。</li>
</ol>
<p>最后让我们再次感谢一下田老师，呱唧呱唧~~~</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/03/js中的类型转换/" rel="next" title="Js中的数值类型转化规则">
                <i class="fa fa-chevron-left"></i> Js中的数值类型转化规则
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Dong" />
          <p class="site-author-name" itemprop="name">Dong</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">25</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#准备工作"><span class="nav-number">1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完成html的基本布局"><span class="nav-number">2.</span> <span class="nav-text">完成html的基本布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用vue完成nodes简单排版"><span class="nav-number">3.</span> <span class="nav-text">使用vue完成nodes简单排版</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完成单个节点的拖拽"><span class="nav-number">4.</span> <span class="nav-text">完成单个节点的拖拽</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#拖拽事件"><span class="nav-number">4.1.</span> <span class="nav-text">拖拽事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拖拽节点"><span class="nav-number">4.2.</span> <span class="nav-text">拖拽节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dragStart"><span class="nav-number">4.2.1.</span> <span class="nav-text">dragStart</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#drag"><span class="nav-number">4.2.2.</span> <span class="nav-text">drag</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dragEnd"><span class="nav-number">4.2.3.</span> <span class="nav-text">dragEnd</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使placeholder可以跟随拖拽节点运动"><span class="nav-number">5.</span> <span class="nav-text">使placeholder可以跟随拖拽节点运动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nodes重排及上移"><span class="nav-number">6.</span> <span class="nav-text">nodes重排及上移</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二维数组的构建"><span class="nav-number">6.1.</span> <span class="nav-text">二维数组的构建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布局方法"><span class="nav-number">6.2.</span> <span class="nav-text">布局方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关节点的下移"><span class="nav-number">7.</span> <span class="nav-text">相关节点的下移</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缩放"><span class="nav-number">8.</span> <span class="nav-text">缩放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fix-解决碰撞位置靠上的大块，并没有下移的问题"><span class="nav-number">9.</span> <span class="nav-text">[fix]解决碰撞位置靠上的大块，并没有下移的问题</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dong</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
